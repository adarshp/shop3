(in-package :shop-user)

;;;
;;; *** Solution Converter ***
;;; 
;;; The main function is solution-converter, which takes five
;;; parameters and one optional parameter
;;;
;;;   (1) a list of plans generated by SHOP2
;;;   (2) the CPU time SHOP2 takes to produce the plans
;;;   (3) the PDDL domain description
;;;   (4) the output file name, .e.g, "taxi1sol"
;;;   (5) a boolean value indicating that plans are concurrent or not.
;;;
;;; Optionally, we can specify is a list of invisible actions which
;;; is not going to present in the output plan.  It is specified by
;;; the keyword: invisible-actions.  By default, all internal operators,
;;; which begin with double exclamation marks (!!), are invisible.
;;;
;;; The output will be written to the designated output file.
;;; If there are more than one plans, each of the PDDL plans will be
;;; written to "taxi1sol-1", "taxi1sol-2", etc.
;;;
;;; *** Example ***
;;;
;;; For example, consider the taxi domain in the AIPS'02 Planning Competition.
;;; To generate a PDDL plan for the problem "taxi1", use the following commands
;;;
;;;  (multiple-value-bind (sol soltime) (find-plans 'taxi1)
;;;    (solution-converter sol soltime "taxi.pddl" "taxi1.soln" t))
;;;
;;; Then the PDDL plan will be written to "taxi1sol".
;;;
;;; Notice that if more than one plan is converted, the timing may
;;; not be correct.
;;;
;;; *** Important: The format of the SHOP2 actions ***
;;;
;;; For concurrent plan, all actions, both durative actions and non-durative
;;; actions, have two more parameters at the end of the parameter list.  The
;;; second last parameter of an action is the time stamp, and the last parameter
;;; is the duration of the action.
;;;

;;; -----------------------------------------------------------------------
;;; REVISION LOG
;;;
;;; 2002.4.10 (chiu)  I fixed a bug in the procedure make-ser-action.
;;; 
;;; 2002.4.2  (chiu)  The zero cost operators are no longer invisible.
;;;                   Instead, internal operators (whose begin with !!) are
;;;                   invisible.
;;;


;;; creat a flat plan, a plan without hierarchical structure,
;;; and get rid of the zero cost actions and invisible actions
(defun make-flat-plan (hplan invisible-actions)
  (let ((fplan nil))
    (do* ((tt (pop hplan) (pop hplan))
          (cc (pop hplan) (pop hplan)))
         ((not cc))
      (when (and (not (and (eql (char (symbol-name (first tt)) 0) #\!)
                           (eql (char (symbol-name (first tt)) 1) #\!)))
                 (not (member (car tt) invisible-actions)))
        (push tt fplan)))
    (reverse fplan)))

;;; Translate a concurrent plan in the SHOP2 format to a structure
;;; for print-concurrent-plan.  The result of this function is a list
;;; of triples:
;;;   (1) Time stamp, (2) the action, and (3) the duration.
(defun make-plan-schedule (fplan dur-action-list ser-action-list)
  (let* ((fplan2 nil))
    (dolist (act fplan)
      (let ((act-name (read-from-string
                       (string-left-trim "!" (symbol-name (first act))))))
        (if (member act-name ser-action-list)
            (push (make-ser-action act-name act) fplan2)
            (if (member act-name dur-action-list)
                (push (make-dur-action act-name act) fplan2)
                (error "Unknown action: ~A" act)))))  ;; never occur
    fplan2))

(defun make-ser-action (head act)
  (list (nth (- (length act) 2) act)
        (reverse (cddr (reverse (cons head (cdr act)))))
        nil))

(defun make-dur-action (head act)
  (list (nth (- (length act) 2) act)
        (reverse (cddr (reverse (cons head (cdr act)))))
        (nth (- (length act) 1) act)))

;;; print a serial plan in PDDL format
(defun print-serial-plan (fplan soltime outfilename)
  (with-open-file (outfile outfilename :direction :output
                                       :if-exists :supersede)
    (let* ((i 1))
      (dolist (act fplan)
        (let ((act-name (read-from-string
                         (string-left-trim "!" (symbol-name (first act))))))
          (format outfile "~A:~A~%" i (cons act-name (cdr act)))
          (setf i (1+ i)))))
    (format outfile "Time ~A~%" (round (* soltime 1000)))))

;;; print a concurrent plan in PDDL format
(defun compare-action (a b)
  (< (first a) (first b)))

(defun print-concurrent-plan (fplan soltime dur-action-list
                              ser-action-list outfilename)
  (with-open-file (outfile outfilename :direction :output
                                       :if-exists :supersede)
    (let* ((fplan2 (make-plan-schedule fplan dur-action-list ser-action-list))
           (sorted-plan (sort fplan2 #'compare-action)))  ;; destroy fplan2
      (dolist (act sorted-plan)
        (if (null (third act))
            (format outfile "~,2F:~A~%" (first act) (second act))
            (progn
              (format outfile "~,2F:~A[~A]~%"
                (first act)
                (second act)
                (third act))))))
    (format outfile "Time ~A~%" (round (* soltime 1000)))))

;;; This is the main function which translate a plan in SHOP2 format
;;; into a PDDL format.  The input parameters are 
;;;   (1) a list of plans generated by SHOP2
;;;   (2) the CPU time SHOP2 takes to produce the plans
;;;   (3) the PDDL domain description
;;;   (4) the output file name, .e.g, "taxi1sol"
;;;   (5) a boolean value indicating that plans are concurrent or not.
;;; Optionally, we can specify is a list of invisible actions which
;;; is not going to present in the output plan.  It is specified by
;;; the keyword: invisible-actions.  By default, all internal operators,
;;; which begin with double exclamation marks (!!), are invisible.

(defun solution-converter (plan-list soltime pddl-filename outfilename
                           is-it-a-concurrent-plan &key invisible-actions)

  (if is-it-a-concurrent-plan
      (format t "Converting a concurrent plan...~%")
      (format t "Converting a sequential plan...~%"))

  (let* ((is-extend-name (= (length plan-list) 1))
         (i 0))
    (when (> (length plan-list) 1)
      (format t "More than 1 plan is converted.  The timing may not be correct.~%")
    )
    (dolist (plan plan-list)
      (setf i (1+ i))
      (let* ((fplan (make-flat-plan plan invisible-actions))
             (dur-action-list nil)
             (ser-action-list nil)
             (outfilename2
               (if is-extend-name
                   outfilename
                   (concatenate 'string outfilename "-" (format nil "~A" i)))))

        ;;; Determine the list of durative action and non-durative action.
        ;;; according to the PDDL file.
        (with-open-file (infile pddl-filename :direction :input)
          (let ((pddl-domain (read infile)))
            (dolist (s pddl-domain)
              (when (and (listp s) (eql (first s) :durative-action))
                 (push (second s) dur-action-list))
              (when (and (listp s) (eql (first s) :action))
                 (push (second s) ser-action-list)))))

        (if is-it-a-concurrent-plan
            (print-concurrent-plan fplan soltime dur-action-list
                                 ser-action-list outfilename2)
            (print-serial-plan fplan soltime outfilename2)))))
  t)

;;; THE END ;;;
